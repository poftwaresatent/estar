------------------------------------------------------------------------
r218 | poftwaresatent | 2007-12-06 14:22:38 -0800 (Thu, 06 Dec 2007) | 5 lines
Changed paths:
   M /branches/estar--supergrid-rfct-0/bin/test_estar_gfx.cpp
   M /branches/estar--supergrid-rfct-0/bin/test_estar_queue.cpp
   M /branches/estar--supergrid-rfct-0/bin/test_estar_replanner.cpp
   M /branches/estar--supergrid-rfct-0/estar/Facade.cpp
   M /branches/estar--supergrid-rfct-0/estar/LSMKernel.cpp
   M /branches/estar--supergrid-rfct-0/estar/LSMKernel.hpp

LSMKernel now uses GridCSpace instead of Grid. That change was really
minimally invasive given the preparations of the past three days, and
now it will be straightforward to plug other grid representations into
LSMKernel.

------------------------------------------------------------------------
r217 | poftwaresatent | 2007-12-06 02:32:05 -0800 (Thu, 06 Dec 2007) | 12 lines
Changed paths:
   M /branches/estar--supergrid-rfct-0/bin/estar_compare_gfx.cpp
   M /branches/estar--supergrid-rfct-0/bin/test_estar_gfx.cpp
   M /branches/estar--supergrid-rfct-0/bin/test_pnf_gfx.cpp
   M /branches/estar--supergrid-rfct-0/estar/CSpace.hpp
   M /branches/estar--supergrid-rfct-0/estar/Facade.cpp
   M /branches/estar--supergrid-rfct-0/estar/Facade.hpp
   M /branches/estar--supergrid-rfct-0/estar/FacadeReadInterface.hpp
   M /branches/estar--supergrid-rfct-0/estar/Grid.cpp
   M /branches/estar--supergrid-rfct-0/estar/GridNode.hpp
   M /branches/estar--supergrid-rfct-0/estar/LSMKernel.hpp
   M /branches/estar--supergrid-rfct-0/estar/graphics.cpp
   M /branches/estar--supergrid-rfct-0/estar/graphics.hpp
   M /branches/estar--supergrid-rfct-0/pnf/Flow.cpp
   M /branches/estar--supergrid-rfct-0/pnf/Flow.hpp

Tidying up the mess in FacadeReadInterface. Using the new CSpace and
its iteration API (which was extended to include iteration over
neighborhoods) throughout graphics and many other places. This feels
*right* because I can delete more lines of code than I need to add.

The dump.cpp interfaces are kind of dependend on actual grid access
(printing to console is sort of simplified when you can assume a
global ordering on your grid), so I'll keep that "friend" with Facade.

GridCSpace also extended to handle bounding box computation, which has
been moved into Grid, basically.

------------------------------------------------------------------------
r216 | poftwaresatent | 2007-12-06 00:48:50 -0800 (Thu, 06 Dec 2007) | 8 lines
Changed paths:
   M /branches/estar--supergrid-rfct-0/bin/test_estar.cpp
   M /branches/estar--supergrid-rfct-0/bin/test_estar_gfx.cpp
   M /branches/estar--supergrid-rfct-0/bin/test_estar_queue.cpp
   M /branches/estar--supergrid-rfct-0/bin/test_estar_replanner.cpp
   M /branches/estar--supergrid-rfct-0/estar/CSpace.cpp
   M /branches/estar--supergrid-rfct-0/estar/CSpace.hpp
   M /branches/estar--supergrid-rfct-0/estar/Facade.cpp
   M /branches/estar--supergrid-rfct-0/estar/Facade.hpp
   M /branches/estar--supergrid-rfct-0/estar/Grid.cpp
   M /branches/estar--supergrid-rfct-0/estar/Grid.hpp
   M /branches/estar--supergrid-rfct-0/estar/GridNode.hpp
   M /branches/estar--supergrid-rfct-0/estar/base.hpp
   M /branches/estar--supergrid-rfct-0/estar/dump.cpp
   M /branches/estar--supergrid-rfct-0/estar/graphics.cpp
   M /branches/estar--supergrid-rfct-0/estar/graphics.hpp

GridCSpace now created by Grid: requires changes in ctor calls of
Grid, Algorithm, and Facade. grid_postransform functionality added to
GridCSpace, which turns out to be a smart move for graphics. Moved
vector_read_iteration to CSpace.hpp and added BaseCSpace::begin() to
make it *really* easy to loop over all vertices and do useful stuff
with them (see changes in graphics.cpp and dump.cpp). First test in
draw_grid_value(), will do this throughout graphics now.

------------------------------------------------------------------------
r215 | poftwaresatent | 2007-12-05 23:37:05 -0800 (Wed, 05 Dec 2007) | 60 lines
Changed paths:
   M /branches/estar--supergrid-rfct-0/bin/test_estar.cpp
   M /branches/estar--supergrid-rfct-0/bin/test_estar_gfx.cpp
   M /branches/estar--supergrid-rfct-0/bin/test_estar_queue.cpp
   M /branches/estar--supergrid-rfct-0/bin/test_estar_replanner.cpp
   M /branches/estar--supergrid-rfct-0/estar
   M /branches/estar--supergrid-rfct-0/estar/Algorithm.cpp
   M /branches/estar--supergrid-rfct-0/estar/Algorithm.hpp
   A /branches/estar--supergrid-rfct-0/estar/CSpace.cpp
   A /branches/estar--supergrid-rfct-0/estar/CSpace.hpp
   M /branches/estar--supergrid-rfct-0/estar/Facade.cpp
   M /branches/estar--supergrid-rfct-0/estar/Facade.hpp
   M /branches/estar--supergrid-rfct-0/estar/FacadeReadInterface.hpp
   M /branches/estar--supergrid-rfct-0/estar/Grid.cpp
   M /branches/estar--supergrid-rfct-0/estar/Grid.hpp
   M /branches/estar--supergrid-rfct-0/estar/GridNode.hpp
   M /branches/estar--supergrid-rfct-0/estar/Makefile.am
   M /branches/estar--supergrid-rfct-0/estar/base.hpp
   M /branches/estar--supergrid-rfct-0/estar/check.cpp
   M /branches/estar--supergrid-rfct-0/estar/dump.cpp
   M /branches/estar--supergrid-rfct-0/estar/graphics.cpp
   M /branches/estar--supergrid-rfct-0/estar/util.hpp
   M /branches/estar--supergrid-rfct-0/pnf/Flow.cpp

Big step at the foundation in order to more elegantly solve the issue
of keeping the core Algorithm completely independent of extra
structure (such as grid information) while making it easy to (i) add
custom data to the vertices of the C-space and (ii) generically say
that a grid is a kind of C-space and that Facade relies on grid
semantics.

The new class hierarchy around estar::CSpace does that by wrapping
around the "hardcore" cspace_t boost Graph representation:

- BaseCSpace defines the interface we need at the core of E* to access
  and modify the data atteched to vertices. It contains property maps
  for value, meta, rhs, and the flag, along with get/set
  methods. There are also methods for adding vertices and edges to the
  underlying cspace_t graph, but vertex addition is protected such
  that clients can create and modify graphs only through one of the
  subclasses. This limitation is useful because it forces client code
  to "be aware" of the need to specify any custom data.

- CSpace simply inherits BaseCSpace and makes AddVertex() public
  instead of protected. So for clients that do not require any custom
  data attached to their vertices, this is the straightforward CSpace
  model to use.

- CustomCSpace is another subclass of BaseCSpace, but furthermore it
  is specialized through a template mechanism which allows clients to
  add custom data to vertices. The aim of this class is to make it
  very easy to attach any sort of supplementary data, and access it
  using the straightforward Lookup() methods which map vertex IDs to
  the instances of the custom data. The AddVertex() method of
  CustomCSpace makes sure that clients don't forget to specify their
  custom data for each vertex that they create.

How does CustomCSpace help us solve the grid-genericity problem? The
trick resides in using GridNode as custom data. Thus, GridCSpace is a
subclass of CustomCSpace<GridNode> (well, actually we use a shared
pointer, and it probably doesn't need to be a subclass but could just
be a typedef - but anyway). Now, Facade and grid-like instances can
hold on to a GridCSpace instance along with the grid-specific
structure provided through GridNode, which gets automatically stored
along with each vertex, and polymorphically pass that instance to
Algorithm which does not need to care about the extra payload.

For this to work, all C-space addition methods were removed from
Algorithm, and it now requires a CSpace pointer upon
construction. Bingo! People who use Facade can access the generic grid
semantics through GridNode placeholders and can stay happily oblivious
of the exact grid-like classes involved in the process.

This is a pretty fundamental change as it acts on the data
representation of the planning space, so lots of (relatively small)
adjustments had to be made throughout the project code. And I haven't
done the proper cleanup of the FacadeReadInterface construction site
yet (which will force many changes to adopt generic vertex iteration
in all remaining places).





------------------------------------------------------------------------
r214 | poftwaresatent | 2007-12-05 16:04:39 -0800 (Wed, 05 Dec 2007) | 1 line
Changed paths:
   M /branches/estar--supergrid-rfct-0/bin/estar_compare_gfx.cpp
   M /branches/estar--supergrid-rfct-0/bin/test_estar.cpp
   M /branches/estar--supergrid-rfct-0/bin/test_estar_gfx.cpp
   M /branches/estar--supergrid-rfct-0/bin/test_estar_queue.cpp
   M /branches/estar--supergrid-rfct-0/bin/test_estar_replanner.cpp
   M /branches/estar--supergrid-rfct-0/bin/test_pnf_gfx.cpp
   M /branches/estar--supergrid-rfct-0/estar/ComparisonFacade.cpp
   M /branches/estar--supergrid-rfct-0/estar/ComparisonFacade.hpp
   M /branches/estar--supergrid-rfct-0/estar/Facade.cpp
   M /branches/estar--supergrid-rfct-0/estar/Facade.hpp
   M /branches/estar--supergrid-rfct-0/estar/FacadeReadInterface.hpp
   M /branches/estar--supergrid-rfct-0/estar/FacadeWriteInterface.hpp
   M /branches/estar--supergrid-rfct-0/estar/Grid.cpp
   M /branches/estar--supergrid-rfct-0/estar/Grid.hpp
   M /branches/estar--supergrid-rfct-0/estar/GridNode.hpp
   M /branches/estar--supergrid-rfct-0/estar/Supergrid.cpp
   M /branches/estar--supergrid-rfct-0/estar/Supergrid.hpp
   M /branches/estar--supergrid-rfct-0/estar/dump.cpp
   M /branches/estar--supergrid-rfct-0/estar/dump.hpp
   M /branches/estar--supergrid-rfct-0/estar/graphics.cpp
   M /branches/estar--supergrid-rfct-0/estar/graphics.hpp
   M /branches/estar--supergrid-rfct-0/pnf/Flow.cpp
   M /branches/estar--supergrid-rfct-0/pnf/Flow.hpp

unified usage of signed grid indices (ssize_t) and removed the Grid-specific igrid field of GridNode
------------------------------------------------------------------------
r212 | poftwaresatent | 2007-12-05 01:01:38 -0800 (Wed, 05 Dec 2007) | 73 lines
Changed paths:
   M /branches/estar--supergrid-rfct-0/bin/estar_compare_gfx.cpp
   M /branches/estar--supergrid-rfct-0/bin/test_estar_gfx.cpp
   M /branches/estar--supergrid-rfct-0/bin/test_pnf_gfx.cpp
   M /branches/estar--supergrid-rfct-0/estar/Facade.cpp
   M /branches/estar--supergrid-rfct-0/estar/Facade.hpp
   M /branches/estar--supergrid-rfct-0/estar/FacadeReadInterface.hpp
   M /branches/estar--supergrid-rfct-0/estar/Grid.cpp
   M /branches/estar--supergrid-rfct-0/estar/Grid.hpp
   A /branches/estar--supergrid-rfct-0/estar/GridNode.hpp
   M /branches/estar--supergrid-rfct-0/estar/Makefile.am
   M /branches/estar--supergrid-rfct-0/estar/base.hpp
   M /branches/estar--supergrid-rfct-0/estar/graphics.cpp
   M /branches/estar--supergrid-rfct-0/estar/graphics.hpp
   M /branches/estar--supergrid-rfct-0/estar/util.cpp
   M /branches/estar--supergrid-rfct-0/estar/util.hpp
   M /branches/estar--supergrid-rfct-0/pnf/Flow.cpp

Big steps towards making more things independent of the exact grid
semantics. Still sometimes relying on hacked friendship with
FacadeReadInterface for direct grid access though (made GetGrid()
protected to find all the places in the code that rely on direct grid
access through the Facade).

--------------------------------------------------

Things that are relevant also outside of the current
Supergrid-refactoring:

estar/Facade.cpp
  New method TraceCarrot() is FINALLY the move of trace_carrot() from
  util free function to where it conceptually belongs. People seem to
  have a hard time figuring out how to create a path, and now they
  have the method for that sitting right in the Facade.

estar/util.cpp
  Moved trace_carrot() and compute_stable_scaled_gradient() out of
  here, the latter went to Grid::ComputeStableScaledGradient(). 

estar/Grid.cpp
  New grid_postransform_cartesian and grid_postransform_hexgrid
  functors provide generic support for figuring out the coordinates
  corresponding to grid indices. ComputeStableScaledGradient() is the
  old free function from util. Moved GridNode class declaration into
  its own header file along with a standalone declaration of the
  GridNode property map (so that other can acces grid-related info for
  each vertex without including Grid.hpp).

--------------------------------------------------

Other things:

estar/FacadeReadInterface.hpp
  ...is a big construction site right now, don't look too closely...

estar/Facade.cpp
  Added GetGridPosTransform() for old graphics code that needs to know
  whether we have a hexgrid or orthogrid. Added GetGridNodeMap() for
  code that needs to know the grid indices of a vertex. Added
  GetVertexReadIteration() to make it easier for client code to
  iterate over all vertices of the C-space graph.

estar/base.hpp
  New struct vertex_read_iteration is a pretty nifty helper for
  iterating over C-space and reading some related properties. This is
  going to be a major help for grid-independence.

estar/GridNode.hpp
  New header for giving some grid-internal info (such as grid indices
  of vertices) to those other classes that absolutely need
  it. Sometime in the future this will be converted to Supergrid
  format...

estar/graphics.cpp
  Moved pfunc_t stuff to Grid. Changed draw_trace() to use the actual
  TraceCarrot() which now lives in Facade. Implemented first
  grid-independent iteration over all C-space vertices here (but that
  doesn't use the new vertex_read_iteration struct from base.hpp).

bin/test_pnf_gfx.cpp
  Adapted to changes in draw_trace().

bin/test_estar_gfx.cpp
  Adapted to changes in draw_trace().

pnf/Flow.cpp
  Use the new vertex_read_iteration to loop over all vertices and
  access the various properties attached to the vartices (including
  grid nodes in some cases). Still sometimes relying on hacked
  friendship for direct grid access though.

------------------------------------------------------------------------
r211 | poftwaresatent | 2007-12-04 19:30:09 -0800 (Tue, 04 Dec 2007) | 3 lines
Changed paths:
   M /branches/estar--supergrid-rfct-0/estar/Facade.cpp
   M /branches/estar--supergrid-rfct-0/estar/Facade.hpp
   M /branches/estar--supergrid-rfct-0/estar/FacadeReadInterface.hpp
   M /branches/estar--supergrid-rfct-0/estar/dump.cpp
   M /branches/estar--supergrid-rfct-0/estar/graphics.cpp
   M /branches/estar--supergrid-rfct-0/estar/util.cpp
   M /branches/estar--supergrid-rfct-0/gfx/Mousehandler.cpp

Removed direct access to grid size through FacadeReadInterface,
replaced where possible by new FacadeReadInterface::IsValidIndex().

------------------------------------------------------------------------
r209 | poftwaresatent | 2007-12-04 15:45:21 -0800 (Tue, 04 Dec 2007) | 7 lines
Changed paths:
   M /branches/estar--supergrid-rfct-0
   M /branches/estar--supergrid-rfct-0/bin
   M /branches/estar--supergrid-rfct-0/estar/Facade.cpp
   M /branches/estar--supergrid-rfct-0/estar/Facade.hpp
   M /branches/estar--supergrid-rfct-0/estar/Makefile.am
   A /branches/estar--supergrid-rfct-0/estar/Supergrid.cpp
   A /branches/estar--supergrid-rfct-0/estar/Supergrid.hpp
   M /branches/estar--supergrid-rfct-0/gfx
   M /branches/estar--supergrid-rfct-0/pnf

First step: use Supergrid in Facade, but always only with one Grid
instance at (0, 0) and thus keep the outside world happily oblivious
of the change.
Next steps: minimize direct use of Grid, use signed grid indices in
Facade and its clients, then switch to Supergrid access in Facade
API.

------------------------------------------------------------------------
r208 | poftwaresatent | 2007-12-04 00:32:33 -0800 (Tue, 04 Dec 2007) | 1 line
Changed paths:
   M /branches/estar--supergrid-rfct-0/estar/Makefile.am

some more headers for install target
------------------------------------------------------------------------
r207 | poftwaresatent | 2007-12-04 00:29:09 -0800 (Tue, 04 Dec 2007) | 5 lines
Changed paths:
   M /branches/estar--supergrid-rfct-0/bin/test_flexgrid.cpp
   M /branches/estar--supergrid-rfct-0/estar/flexgrid.hpp
   M /branches/estar--supergrid-rfct-0/estar/flexgrid_iterator.hpp

Several hours of headache with template programming later... a "nicer"
iterator for flexgrid, with const and non-const variants and much more
extensive testing. Geez, what a way to get sidetracked, but learned a
lot.

------------------------------------------------------------------------
r206 | poftwaresatent | 2007-12-03 20:08:59 -0800 (Mon, 03 Dec 2007) | 5 lines
Changed paths:
   M /branches/estar--supergrid-rfct-0/bin/test_flexgrid.cpp
   M /branches/estar--supergrid-rfct-0/estar/flexgrid.hpp
   A /branches/estar--supergrid-rfct-0/estar/flexgrid_iterator.hpp
   A /branches/estar--supergrid-rfct-0/estar/flexgrid_traits.hpp

A bidirectional iterator for flexgrid, needed to provide flexible
"loop over all subgrids" semantics, which are needed to get rid of the
dependence on grid dimensions in many places (and thus make them more
independent of supergrid vs subgrid).

------------------------------------------------------------------------
r205 | poftwaresatent | 2007-12-03 14:50:41 -0800 (Mon, 03 Dec 2007) | 1 line
Changed paths:
   A /branches/estar--supergrid-rfct-0 (from /trunk/estar:204)

sandbox for implementing Supergrid and using it instead of Grid in (some/most?) places
------------------------------------------------------------------------
r204 | poftwaresatent | 2007-12-03 10:44:56 -0800 (Mon, 03 Dec 2007) | 36 lines
Changed paths:
   A /trunk/estar/bin/test_flexgrid.cpp
   M /trunk/estar/estar/Makefile.am
   A /trunk/estar/estar/flexgrid.hpp
   A /trunk/estar/estar/sdeque.hpp

Added a foundation for developing growable grids. The idea is that the
robot can start exploring with just a relatively small local grid, and
expand it as more of the environment comes into view.

The idea is the following: Instead of opting for a general
multiresolution grid approach, I've decided to keep it relatively
simple and aim for a "grid of grids" where each subgrid (a cell of the
supergrid) contains a estar::Grid instance. Whenever we add a new
super-cell, we instantiate a new estar::Grid and "glue" its edges to
its surrounding neighbors. The supergrid will grow in a rectangular
fashion to keep it easy to manage, but some (or even most) of the
super-cells will just be null-pointers. The structure of the
sub-cells, which contain actual estar::Grid instances, will reflect
which regions of the supergrid have *actual* data in them.

The next step is to implement a Supergrid class and either:
1) make its API compatible with Grid to use it interchangeably
2) or change the current code such that it directly accesses Supergrid
3) or change the code such that it only needs to see a given sub-cell
   at a time

Which one of these is most appropriate will emerge during work on
Supergrid. The foundation for implementing it are coded as templates
that provide a type-neutral "automatically" growing 2D array:

estar/sdeque.hpp:
 Implementation of "deque" with signed index, such that (conceptually)
 the data stays in place when resizing the deque.

estar/flexgrid.hpp:
 Implementation of a "flexible" grid, which is like a sdeque in two
 dimensions.

bin/test_flexgrid.cpp:
  Test program for sdeque and flexgrid.
